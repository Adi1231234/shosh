<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>בהצלחה שוש</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@200;300;400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Heebo', sans-serif;
  background: #080008;
  color: #fff;
  overflow-x: hidden;
  min-height: 100vh;
  -webkit-tap-highlight-color: transparent;
}

canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 0;
}

.content {
  position: relative;
  z-index: 5;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 2rem;
  text-align: center;
}

.title {
  font-size: clamp(2.8rem, 10vw, 5.5rem);
  font-weight: 700;
  letter-spacing: -0.02em;
  color: #fff;
  opacity: 0;
  transform: translateY(40px);
  animation: revealText 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.5s forwards;
}

.subtitle {
  font-size: clamp(1.2rem, 4vw, 1.8rem);
  font-weight: 300;
  color: rgba(255, 255, 255, 0.7);
  margin-top: 1rem;
  opacity: 0;
  transform: translateY(20px);
  animation: revealText 1s cubic-bezier(0.16, 1, 0.3, 1) 1s forwards;
}

.line {
  width: 60px;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(180, 40, 60, 0.8), transparent);
  margin: 2rem auto;
  opacity: 0;
  animation: revealText 1s ease 1.4s forwards;
}

.anatomy-text {
  font-size: clamp(1rem, 3vw, 1.3rem);
  font-weight: 300;
  color: rgba(200, 60, 80, 0.8);
  letter-spacing: 0.3em;
  text-transform: uppercase;
  opacity: 0;
  transform: translateY(15px);
  animation: revealText 1s cubic-bezier(0.16, 1, 0.3, 1) 1.7s forwards;
}

.bottom-note {
  position: fixed;
  bottom: 2rem;
  left: 0; right: 0;
  text-align: center;
  font-size: 0.75rem;
  font-weight: 200;
  color: rgba(255,255,255,0.15);
  z-index: 5;
  opacity: 0;
  animation: revealText 1s ease 2.5s forwards;
}

@keyframes revealText {
  to { opacity: 1; transform: translateY(0); }
}

/* No DOM-based touch effects - all on canvas */
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="content">
  <div class="title">בהצלחה, שוש</div>
  <div class="subtitle">את תהיי מדהימה</div>
  <div class="line"></div>
  <div class="anatomy-text">אנטומיה · כלי דם</div>
</div>

<div class="bottom-note">גע במסך</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;
let mouse = { x: null, y: null, active: false };
let time = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// --- Vein network ---
// Organic branching vessel paths that respond to touch
class Vessel {
  constructor() {
    this.points = [];
    this.generate();
    this.width = Math.random() * 2 + 0.5;
    this.speed = Math.random() * 0.3 + 0.1;
    this.offset = Math.random() * 1000;
    this.hue = Math.random() > 0.3 ? 0 : 230; // red or blue
    this.alpha = Math.random() * 0.12 + 0.03;
    this.pulsePhase = Math.random() * Math.PI * 2;
  }

  generate() {
    const startSide = Math.floor(Math.random() * 4);
    let x, y;
    if (startSide === 0) { x = 0; y = Math.random() * H; }
    else if (startSide === 1) { x = W; y = Math.random() * H; }
    else if (startSide === 2) { x = Math.random() * W; y = 0; }
    else { x = Math.random() * W; y = H; }

    this.points = [{ x, y }];
    const segments = Math.floor(Math.random() * 8 + 6);
    for (let i = 0; i < segments; i++) {
      const last = this.points[this.points.length - 1];
      const angle = Math.atan2(H/2 - last.y, W/2 - last.x) + (Math.random() - 0.5) * 1.5;
      const dist = Math.random() * 120 + 60;
      this.points.push({
        x: last.x + Math.cos(angle) * dist,
        y: last.y + Math.sin(angle) * dist
      });
    }
  }

  draw(t) {
    if (this.points.length < 2) return;
    const pulse = Math.sin(t * 0.002 + this.pulsePhase) * 0.5 + 0.5;
    const alpha = this.alpha * (0.6 + pulse * 0.4);

    // Proximity glow
    let proxBoost = 0;
    if (mouse.active) {
      for (const p of this.points) {
        const d = Math.hypot(p.x - mouse.x, p.y - mouse.y);
        if (d < 200) proxBoost = Math.max(proxBoost, (1 - d / 200) * 0.3);
      }
    }

    ctx.beginPath();
    ctx.moveTo(this.points[0].x, this.points[0].y);
    for (let i = 1; i < this.points.length - 1; i++) {
      const xc = (this.points[i].x + this.points[i + 1].x) / 2;
      const yc = (this.points[i].y + this.points[i + 1].y) / 2;
      ctx.quadraticCurveTo(this.points[i].x, this.points[i].y, xc, yc);
    }
    const last = this.points[this.points.length - 1];
    ctx.lineTo(last.x, last.y);

    const r = this.hue === 0 ? 140 : 60;
    const g = this.hue === 0 ? 20 : 60;
    const b = this.hue === 0 ? 30 : 140;
    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha + proxBoost})`;
    ctx.lineWidth = this.width + pulse * 0.5 + proxBoost * 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();

    // Flow particles along vessel
    this.drawFlow(t, alpha + proxBoost);
  }

  drawFlow(t, alpha) {
    const flowPos = ((t * this.speed * 0.001 + this.offset) % 1);
    const totalLen = this.points.length - 1;
    const idx = Math.floor(flowPos * totalLen);
    const frac = (flowPos * totalLen) - idx;
    if (idx >= this.points.length - 1) return;

    const p1 = this.points[idx];
    const p2 = this.points[idx + 1];
    const fx = p1.x + (p2.x - p1.x) * frac;
    const fy = p1.y + (p2.y - p1.y) * frac;

    const r = this.hue === 0 ? 200 : 100;
    const g = this.hue === 0 ? 30 : 100;
    const b = this.hue === 0 ? 40 : 200;

    ctx.beginPath();
    ctx.arc(fx, fy, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r},${g},${b},${Math.min(alpha * 3, 0.5)})`;
    ctx.shadowColor = `rgba(${r},${g},${b},0.5)`;
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// --- Floating cells (subtle, organic) ---
class Cell {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = Math.random() * W;
    this.y = H + Math.random() * 50;
    this.size = Math.random() * 3 + 1;
    this.vy = -(Math.random() * 0.3 + 0.08);
    this.vx = (Math.random() - 0.5) * 0.15;
    this.wobbleSpeed = Math.random() * 0.008 + 0.003;
    this.wobbleAmp = Math.random() * 20 + 10;
    this.phase = Math.random() * Math.PI * 2;
    this.opacity = Math.random() * 0.15 + 0.03;
    this.isBlue = Math.random() > 0.75;
  }
  update(t) {
    this.y += this.vy;
    this.x += this.vx + Math.sin(t * this.wobbleSpeed + this.phase) * 0.2;

    // Repel from touch
    if (mouse.active) {
      const dx = this.x - mouse.x;
      const dy = this.y - mouse.y;
      const d = Math.hypot(dx, dy);
      if (d < 120 && d > 0) {
        const force = (1 - d / 120) * 2;
        this.x += (dx / d) * force;
        this.y += (dy / d) * force;
      }
    }

    if (this.y < -20) this.reset();
  }
  draw() {
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
    if (this.isBlue) {
      ctx.fillStyle = `rgba(80, 80, 160, ${this.opacity})`;
    } else {
      ctx.fillStyle = `rgba(160, 30, 30, ${this.opacity})`;
    }
    ctx.fill();
  }
}

// --- Touch effects ---
let touchEffects = [];

// Branching vessel that grows from touch point
class BranchingVessel {
  constructor(x, y) {
    this.branches = [];
    this.life = 1;
    this.decay = 0.008;
    this.growBranch(x, y, null, 0);
  }
  growBranch(x, y, parent, depth) {
    if (depth > 4) return;
    const branch = { points: [{ x, y }], depth, growing: true, targetLen: Math.floor(Math.random() * 8 + 4) };
    this.branches.push(branch);
    const angle = parent ? (Math.random() * Math.PI * 2) : (Math.random() * Math.PI * 2);
    let curAngle = angle;
    const grow = () => {
      if (!branch.growing || branch.points.length >= branch.targetLen) {
        branch.growing = false;
        // Maybe spawn sub-branches
        if (depth < 3 && Math.random() > 0.3) {
          const last = branch.points[branch.points.length - 1];
          const numSubs = Math.floor(Math.random() * 2 + 1);
          for (let i = 0; i < numSubs; i++) {
            this.growBranch(last.x, last.y, branch, depth + 1);
          }
        }
        return;
      }
      const last = branch.points[branch.points.length - 1];
      curAngle += (Math.random() - 0.5) * 0.8;
      const dist = Math.random() * 15 + 8;
      branch.points.push({ x: last.x + Math.cos(curAngle) * dist, y: last.y + Math.sin(curAngle) * dist });
      setTimeout(grow, 30);
    };
    setTimeout(grow, depth * 80 + Math.random() * 60);
  }
  update() { this.life -= this.decay; }
  draw() {
    if (this.life <= 0) return;
    for (const branch of this.branches) {
      if (branch.points.length < 2) continue;
      const w = Math.max(0.3, (1 - branch.depth * 0.2)) * 2;
      const alpha = this.life * (1 - branch.depth * 0.15);
      ctx.beginPath();
      ctx.moveTo(branch.points[0].x, branch.points[0].y);
      for (let i = 1; i < branch.points.length; i++) {
        ctx.lineTo(branch.points[i].x, branch.points[i].y);
      }
      ctx.strokeStyle = `rgba(200, 40, 60, ${alpha * 0.7})`;
      ctx.lineWidth = w;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = `rgba(220, 50, 70, ${alpha * 0.5})`;
      ctx.shadowBlur = 12;
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Glow dot at tip
      if (branch.growing) {
        const tip = branch.points[branch.points.length - 1];
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 100, 120, ${alpha})`;
        ctx.shadowColor = 'rgba(255, 80, 100, 0.8)';
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }
  }
}

// Shockwave ring
class Shockwave {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.radius = 0;
    this.maxRadius = Math.random() * 100 + 80;
    this.life = 1;
  }
  update() {
    this.radius += 2.5;
    this.life = Math.max(0, 1 - this.radius / this.maxRadius);
  }
  draw() {
    if (this.life <= 0) return;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(180, 40, 60, ${this.life * 0.35})`;
    ctx.lineWidth = 1.5 * this.life;
    ctx.shadowColor = `rgba(200, 50, 70, ${this.life * 0.3})`;
    ctx.shadowBlur = 10;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
}

// Scatter dots
class ScatterDot {
  constructor(x, y) {
    this.x = x; this.y = y;
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 3 + 1.5;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.life = 1;
    this.decay = Math.random() * 0.02 + 0.01;
    this.size = Math.random() * 2.5 + 0.8;
  }
  update() {
    this.x += this.vx; this.y += this.vy;
    this.vx *= 0.96; this.vy *= 0.96;
    this.life -= this.decay;
  }
  draw() {
    if (this.life <= 0) return;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(200, 60, 80, ${this.life * 0.5})`;
    ctx.fill();
  }
}

// Initialize
const vessels = Array.from({ length: 18 }, () => new Vessel());
const cells = Array.from({ length: 40 }, () => new Cell());

// Handle touch/click
function onInteract(x, y) {
  mouse.x = x; mouse.y = y; mouse.active = true;

  // Branching vessel grows from touch
  touchEffects.push(new BranchingVessel(x, y));

  // Shockwave rings
  touchEffects.push(new Shockwave(x, y));
  setTimeout(() => touchEffects.push(new Shockwave(x, y)), 150);

  // Scatter dots
  for (let i = 0; i < 15; i++) {
    touchEffects.push(new ScatterDot(x, y));
  }

  clearTimeout(window._mouseTimeout);
  window._mouseTimeout = setTimeout(() => { mouse.active = false; }, 2000);
}

document.addEventListener('click', e => onInteract(e.clientX, e.clientY));
document.addEventListener('touchstart', e => {
  for (const t of e.touches) onInteract(t.clientX, t.clientY);
}, { passive: true });
document.addEventListener('touchmove', e => {
  for (const t of e.touches) { mouse.x = t.clientX; mouse.y = t.clientY; }
}, { passive: true });

// Heartbeat subtle glow
function drawHeartbeat(t) {
  const beat = Math.pow(Math.sin(t * 0.004) * 0.5 + 0.5, 8);
  if (beat < 0.01) return;
  const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.5);
  gradient.addColorStop(0, `rgba(100, 10, 20, ${beat * 0.06})`);
  gradient.addColorStop(1, 'transparent');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
}

// Main loop
function animate(t) {
  time = t || 0;
  ctx.clearRect(0, 0, W, H);

  drawHeartbeat(time);
  vessels.forEach(v => v.draw(time));
  cells.forEach(c => { c.update(time); c.draw(); });

  touchEffects = touchEffects.filter(e => e.life > 0);
  touchEffects.forEach(e => { e.update(); e.draw(); });

  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
