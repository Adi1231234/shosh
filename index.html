<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>בהצלחה שושי</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@200;300;400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Heebo', sans-serif;
  background: #050005;
  color: #fff;
  overflow: hidden;
  height: 100vh;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  user-select: none;
}

canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
}

.content {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  z-index: 5;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  pointer-events: none;
}

.title {
  font-size: clamp(2.8rem, 10vw, 5.5rem);
  font-weight: 700;
  letter-spacing: -0.02em;
  color: #fff;
  opacity: 0;
  transform: translateY(40px);
  animation: revealText 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.5s forwards;
}

.subtitle {
  font-size: clamp(1.2rem, 4vw, 1.8rem);
  font-weight: 300;
  color: rgba(255, 255, 255, 0.7);
  margin-top: 1rem;
  opacity: 0;
  transform: translateY(20px);
  animation: revealText 1s cubic-bezier(0.16, 1, 0.3, 1) 1s forwards;
}

.line {
  width: 60px;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(180, 40, 60, 0.8), transparent);
  margin: 2rem auto;
  opacity: 0;
  animation: revealText 1s ease 1.4s forwards;
}

.tap-text {
  font-size: clamp(1.6rem, 6vw, 2.2rem);
  font-weight: 700;
  color: rgba(220, 80, 100, 0.9);
  letter-spacing: 0.1em;
  opacity: 0;
  transform: translateY(15px);
  animation: revealText 1s cubic-bezier(0.16, 1, 0.3, 1) 1.7s forwards, tapPulse 1.2s ease-in-out 2.5s infinite;
  text-shadow: 0 0 20px rgba(220, 50, 70, 0.5);
  pointer-events: auto;
  cursor: pointer;
}

@keyframes revealText {
  to { opacity: 1; transform: translateY(0); }
}

@keyframes tapPulse {
  0%, 100% { transform: scale(1); text-shadow: 0 0 15px rgba(220, 50, 70, 0.3); opacity: 0.5; }
  50% { transform: scale(1.25); text-shadow: 0 0 40px rgba(255, 80, 100, 1); opacity: 1; }
}

.hint {
  position: fixed;
  bottom: 2rem;
  left: 0; right: 0;
  text-align: center;
  font-size: 0.75rem;
  font-weight: 200;
  color: rgba(255,255,255,0.15);
  z-index: 5;
  pointer-events: none;
  opacity: 0;
  animation: revealText 1s ease 2.5s forwards;
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<div class="content">
  <div class="title">בהצלחה שושי ❤️</div>
  <div class="subtitle">את הכי טובה בעולם!!! כל הלימודים ישתלמו ואת תהיי הרופאה הכי טובה! ❤️</div>
  <div class="line"></div>
  <div class="tap-text">לחצי עליי</div>
</div>

<div class="hint">גע במסך</div>

<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
let W, H, dpr;

function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth;
  H = window.innerHeight;
  c.width = W * dpr;
  c.height = H * dpr;
}
resize();
window.addEventListener('resize', resize);

// ==============================
// BACKGROUND
// ==============================
function drawBackground(t) {
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  const gx = W * 0.5 + Math.sin(t * 0.0003) * W * 0.2;
  const gy = H * 0.5 + Math.cos(t * 0.0004) * H * 0.15;
  const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, Math.max(W, H) * 0.7);
  grad.addColorStop(0, 'rgba(40, 5, 15, 0.4)');
  grad.addColorStop(0.5, 'rgba(15, 2, 8, 0.3)');
  grad.addColorStop(1, 'rgba(5, 0, 5, 0)');
  ctx.fillStyle = '#050005';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  const beat = Math.pow(Math.max(0, Math.sin(t * 0.004)), 12);
  if (beat > 0.01) {
    const pg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, H * 0.6);
    pg.addColorStop(0, `rgba(80, 10, 20, ${beat * 0.08})`);
    pg.addColorStop(1, 'transparent');
    ctx.fillStyle = pg;
    ctx.fillRect(0, 0, W, H);
  }
}

// ==============================
// VESSEL TREES - pre-computed, no intervals
// ==============================
// Build entire tree synchronously, animate reveal via progress
function buildTree(x, y) {
  const branches = [];
  const queue = [{ x, y, angle: Math.random() * Math.PI * 2, depth: 0 }];

  while (queue.length > 0 && branches.length < 30) {
    const { x, y, angle, depth } = queue.shift();
    if (depth > 5) continue;

    const len = (Math.random() * 200 + 120) * (1 - depth * 0.08);
    const segments = Math.floor(Math.random() * 8 + 4);
    const pts = [{ x, y }];
    let cx = x, cy = y, ca = angle;

    for (let i = 0; i < segments; i++) {
      ca += (Math.random() - 0.5) * 0.6;
      const sl = len / segments;
      cx += Math.cos(ca) * sl;
      cy += Math.sin(ca) * sl;
      pts.push({ x: cx, y: cy });
    }

    branches.push({ pts, depth, totalPts: pts.length });

    // Fork
    if (depth < 4 && Math.random() > 0.3) {
      const forks = depth < 2 ? Math.floor(Math.random() * 2 + 2) : Math.floor(Math.random() * 2 + 1);
      for (let i = 0; i < forks; i++) {
        const spread = (Math.random() - 0.5) * 3.2;
        queue.push({ x: cx, y: cy, angle: ca + spread, depth: depth + 1 });
      }
    }
  }

  return branches;
}

// ==============================
// EFFECT POOL - fixed size arrays
// ==============================
const MAX_TREES = 8;
const MAX_RINGS = 12;
const MAX_PARTICLES = 50;

const trees = [];     // { branches, birth, life }
const rings = [];     // { x, y, r, maxR, life }
const glows = [];     // { x, y, r, maxR, life }
const particles = []; // { x, y, vx, vy, life, decay, size }

function addTree(x, y) {
  // Kill oldest if at cap
  while (trees.length >= MAX_TREES) {
    trees.shift();
  }
  const branches = buildTree(x, y);
  trees.push({ branches, birth: performance.now(), life: 1 });
}

function addRing(x, y) {
  if (rings.length >= MAX_RINGS) rings.shift();
  rings.push({ x, y, r: 0, maxR: Math.random() * 80 + 60, life: 1 });
}

function addGlow(x, y) {
  if (glows.length >= 6) glows.shift();
  glows.push({ x, y, r: 5, maxR: 120, life: 1 });
}

function addParticle(x, y) {
  if (particles.length >= MAX_PARTICLES) particles.shift();
  const a = Math.random() * Math.PI * 2;
  const s = Math.random() * 2.5 + 0.8;
  particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 1, decay: Math.random()*0.018+0.008, size: Math.random()*1.8+0.5 });
}

// ==============================
// DRAW
// ==============================
function drawTrees(t) {
  for (let i = trees.length - 1; i >= 0; i--) {
    const tree = trees[i];
    tree.life -= 0.008;
    if (tree.life <= 0) { trees.splice(i, 1); continue; }

    const elapsed = (t - tree.birth) / 1000; // seconds since birth
    const fade = Math.min(1, tree.life * 2);

    for (const b of tree.branches) {
      // Animated reveal: show points based on time + depth
      const revealTime = elapsed - b.depth * 0.15;
      if (revealTime <= 0) continue;
      const showPts = Math.min(b.pts.length, Math.floor(revealTime * 40) + 1);
      if (showPts < 2) continue;

      const w = Math.max(0.3, 2 - b.depth * 0.35);
      const a = fade * (1 - b.depth * 0.12) * 0.6;

      ctx.beginPath();
      ctx.moveTo(b.pts[0].x, b.pts[0].y);
      for (let j = 1; j < showPts; j++) {
        ctx.lineTo(b.pts[j].x, b.pts[j].y);
      }
      ctx.strokeStyle = `rgba(180, 35, 55, ${a})`;
      ctx.lineWidth = w;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();

      // Tip glow (no shadowBlur - just a circle)
      if (showPts < b.pts.length) {
        const tip = b.pts[showPts - 1];
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, 3 - b.depth * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 120, 140, ${a * 0.8})`;
        ctx.fill();
      }
    }
  }
}

function drawRings() {
  for (let i = rings.length - 1; i >= 0; i--) {
    const r = rings[i];
    r.r += 1.8;
    r.life = Math.max(0, 1 - r.r / r.maxR);
    if (r.life <= 0) { rings.splice(i, 1); continue; }
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(160, 35, 55, ${r.life * 0.3})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

function drawGlows() {
  for (let i = glows.length - 1; i >= 0; i--) {
    const g = glows[i];
    g.r += 1.5;
    g.life = Math.max(0, 1 - g.r / g.maxR);
    if (g.life <= 0) { glows.splice(i, 1); continue; }
    const gr = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.r);
    gr.addColorStop(0, `rgba(180, 40, 60, ${g.life * 0.15})`);
    gr.addColorStop(1, 'transparent');
    ctx.fillStyle = gr;
    ctx.beginPath();
    ctx.arc(g.x, g.y, g.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.97; p.vy *= 0.97;
    p.life -= p.decay;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(190, 50, 70, ${p.life * 0.45})`;
    ctx.fill();
  }
}

// ==============================
// INTERACTION
// ==============================
let lastTap = 0;
function onInteract(x, y) {
  const now = Date.now();
  if (now - lastTap < 200) return;
  lastTap = now;

  for (let i = 0; i < 4; i++) {
    addTree(x + (Math.random()-0.5)*20, y + (Math.random()-0.5)*20);
  }
  addGlow(x, y);
  for (let i = 0; i < 3; i++) addRing(x, y);
  for (let i = 0; i < 10; i++) addParticle(x, y);
}

document.addEventListener('click', e => onInteract(e.clientX, e.clientY));
document.addEventListener('touchstart', e => {
  for (const t of e.touches) onInteract(t.clientX, t.clientY);
}, { passive: true });

// ==============================
// MAIN LOOP
// ==============================
function animate(t) {
  drawBackground(t || 0);
  drawTrees(t || 0);
  drawRings();
  drawGlows();
  drawParticles();
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
