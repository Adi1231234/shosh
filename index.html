<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>בהצלחה שוש</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@200;300;400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Heebo', sans-serif;
  background: #080008;
  color: #fff;
  overflow-x: hidden;
  min-height: 100vh;
  -webkit-tap-highlight-color: transparent;
}

canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 0;
}

.content {
  position: relative;
  z-index: 5;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 2rem;
  text-align: center;
}

.title {
  font-size: clamp(2.8rem, 10vw, 5.5rem);
  font-weight: 700;
  letter-spacing: -0.02em;
  color: #fff;
  opacity: 0;
  transform: translateY(40px);
  animation: revealText 1.2s cubic-bezier(0.16, 1, 0.3, 1) 0.5s forwards;
}

.subtitle {
  font-size: clamp(1.2rem, 4vw, 1.8rem);
  font-weight: 300;
  color: rgba(255, 255, 255, 0.7);
  margin-top: 1rem;
  opacity: 0;
  transform: translateY(20px);
  animation: revealText 1s cubic-bezier(0.16, 1, 0.3, 1) 1s forwards;
}

.line {
  width: 60px;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(180, 40, 60, 0.8), transparent);
  margin: 2rem auto;
  opacity: 0;
  animation: revealText 1s ease 1.4s forwards;
}

.anatomy-text {
  font-size: clamp(1rem, 3vw, 1.3rem);
  font-weight: 300;
  color: rgba(200, 60, 80, 0.8);
  letter-spacing: 0.3em;
  text-transform: uppercase;
  opacity: 0;
  transform: translateY(15px);
  animation: revealText 1s cubic-bezier(0.16, 1, 0.3, 1) 1.7s forwards;
}

.bottom-note {
  position: fixed;
  bottom: 2rem;
  left: 0; right: 0;
  text-align: center;
  font-size: 0.75rem;
  font-weight: 200;
  color: rgba(255,255,255,0.15);
  z-index: 5;
  opacity: 0;
  animation: revealText 1s ease 2.5s forwards;
}

@keyframes revealText {
  to { opacity: 1; transform: translateY(0); }
}

/* Touch ripple */
.touch-ripple {
  position: fixed;
  border-radius: 50%;
  pointer-events: none;
  z-index: 10;
  border: 1px solid rgba(180, 40, 60, 0.5);
  animation: rippleExpand 1.2s cubic-bezier(0, 0.5, 0.3, 1) forwards;
}
.touch-ripple:nth-child(odd) {
  animation-duration: 1.5s;
  border-color: rgba(120, 20, 40, 0.3);
}

@keyframes rippleExpand {
  from { width: 0; height: 0; opacity: 0.8; }
  to { width: 400px; height: 400px; opacity: 0; }
}

/* Burst glow on touch */
.touch-glow {
  position: fixed;
  border-radius: 50%;
  pointer-events: none;
  z-index: 9;
  background: radial-gradient(circle, rgba(180,40,60,0.25), rgba(120,20,40,0.1) 40%, transparent 70%);
  animation: glowFade 1.5s ease-out forwards;
}

@keyframes glowFade {
  from { width: 0; height: 0; opacity: 1; }
  50% { opacity: 0.6; }
  to { width: 500px; height: 500px; opacity: 0; }
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="content">
  <div class="title">בהצלחה, שוש</div>
  <div class="subtitle">את תהיי מדהימה</div>
  <div class="line"></div>
  <div class="anatomy-text">אנטומיה · כלי דם</div>
</div>

<div class="bottom-note">גע במסך</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;
let mouse = { x: null, y: null, active: false };
let time = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// --- Vein network ---
// Organic branching vessel paths that respond to touch
class Vessel {
  constructor() {
    this.points = [];
    this.generate();
    this.width = Math.random() * 2 + 0.5;
    this.speed = Math.random() * 0.3 + 0.1;
    this.offset = Math.random() * 1000;
    this.hue = Math.random() > 0.3 ? 0 : 230; // red or blue
    this.alpha = Math.random() * 0.12 + 0.03;
    this.pulsePhase = Math.random() * Math.PI * 2;
  }

  generate() {
    const startSide = Math.floor(Math.random() * 4);
    let x, y;
    if (startSide === 0) { x = 0; y = Math.random() * H; }
    else if (startSide === 1) { x = W; y = Math.random() * H; }
    else if (startSide === 2) { x = Math.random() * W; y = 0; }
    else { x = Math.random() * W; y = H; }

    this.points = [{ x, y }];
    const segments = Math.floor(Math.random() * 8 + 6);
    for (let i = 0; i < segments; i++) {
      const last = this.points[this.points.length - 1];
      const angle = Math.atan2(H/2 - last.y, W/2 - last.x) + (Math.random() - 0.5) * 1.5;
      const dist = Math.random() * 120 + 60;
      this.points.push({
        x: last.x + Math.cos(angle) * dist,
        y: last.y + Math.sin(angle) * dist
      });
    }
  }

  draw(t) {
    if (this.points.length < 2) return;
    const pulse = Math.sin(t * 0.002 + this.pulsePhase) * 0.5 + 0.5;
    const alpha = this.alpha * (0.6 + pulse * 0.4);

    // Proximity glow
    let proxBoost = 0;
    if (mouse.active) {
      for (const p of this.points) {
        const d = Math.hypot(p.x - mouse.x, p.y - mouse.y);
        if (d < 200) proxBoost = Math.max(proxBoost, (1 - d / 200) * 0.3);
      }
    }

    ctx.beginPath();
    ctx.moveTo(this.points[0].x, this.points[0].y);
    for (let i = 1; i < this.points.length - 1; i++) {
      const xc = (this.points[i].x + this.points[i + 1].x) / 2;
      const yc = (this.points[i].y + this.points[i + 1].y) / 2;
      ctx.quadraticCurveTo(this.points[i].x, this.points[i].y, xc, yc);
    }
    const last = this.points[this.points.length - 1];
    ctx.lineTo(last.x, last.y);

    const r = this.hue === 0 ? 140 : 60;
    const g = this.hue === 0 ? 20 : 60;
    const b = this.hue === 0 ? 30 : 140;
    ctx.strokeStyle = `rgba(${r},${g},${b},${alpha + proxBoost})`;
    ctx.lineWidth = this.width + pulse * 0.5 + proxBoost * 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();

    // Flow particles along vessel
    this.drawFlow(t, alpha + proxBoost);
  }

  drawFlow(t, alpha) {
    const flowPos = ((t * this.speed * 0.001 + this.offset) % 1);
    const totalLen = this.points.length - 1;
    const idx = Math.floor(flowPos * totalLen);
    const frac = (flowPos * totalLen) - idx;
    if (idx >= this.points.length - 1) return;

    const p1 = this.points[idx];
    const p2 = this.points[idx + 1];
    const fx = p1.x + (p2.x - p1.x) * frac;
    const fy = p1.y + (p2.y - p1.y) * frac;

    const r = this.hue === 0 ? 200 : 100;
    const g = this.hue === 0 ? 30 : 100;
    const b = this.hue === 0 ? 40 : 200;

    ctx.beginPath();
    ctx.arc(fx, fy, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r},${g},${b},${Math.min(alpha * 3, 0.5)})`;
    ctx.shadowColor = `rgba(${r},${g},${b},0.5)`;
    ctx.shadowBlur = 12;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// --- Floating cells (subtle, organic) ---
class Cell {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = Math.random() * W;
    this.y = H + Math.random() * 50;
    this.size = Math.random() * 3 + 1;
    this.vy = -(Math.random() * 0.3 + 0.08);
    this.vx = (Math.random() - 0.5) * 0.15;
    this.wobbleSpeed = Math.random() * 0.008 + 0.003;
    this.wobbleAmp = Math.random() * 20 + 10;
    this.phase = Math.random() * Math.PI * 2;
    this.opacity = Math.random() * 0.15 + 0.03;
    this.isBlue = Math.random() > 0.75;
  }
  update(t) {
    this.y += this.vy;
    this.x += this.vx + Math.sin(t * this.wobbleSpeed + this.phase) * 0.2;

    // Repel from touch
    if (mouse.active) {
      const dx = this.x - mouse.x;
      const dy = this.y - mouse.y;
      const d = Math.hypot(dx, dy);
      if (d < 120 && d > 0) {
        const force = (1 - d / 120) * 2;
        this.x += (dx / d) * force;
        this.y += (dy / d) * force;
      }
    }

    if (this.y < -20) this.reset();
  }
  draw() {
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
    if (this.isBlue) {
      ctx.fillStyle = `rgba(80, 80, 160, ${this.opacity})`;
    } else {
      ctx.fillStyle = `rgba(160, 30, 30, ${this.opacity})`;
    }
    ctx.fill();
  }
}

// --- Touch particles ---
let touchParticles = [];
class TouchParticle {
  constructor(x, y) {
    this.x = x; this.y = y;
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.life = 1;
    this.decay = Math.random() * 0.012 + 0.005;
    this.size = Math.random() * 3 + 1;
    this.trail = [];
  }
  update() {
    this.trail.push({ x: this.x, y: this.y, life: this.life });
    if (this.trail.length > 8) this.trail.shift();
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.97;
    this.vy *= 0.97;
    this.vy += 0.02;
    this.life -= this.decay;
  }
  draw() {
    if (this.life <= 0) return;
    // Trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      const a = (i / this.trail.length) * this.life * 0.15;
      ctx.beginPath();
      ctx.arc(t.x, t.y, this.size * (i / this.trail.length), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(180, 40, 60, ${a})`;
      ctx.fill();
    }
    // Main particle
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(200, 50, 70, ${this.life * 0.6})`;
    ctx.shadowColor = 'rgba(200, 40, 60, 0.5)';
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// Initialize
const vessels = Array.from({ length: 18 }, () => new Vessel());
const cells = Array.from({ length: 40 }, () => new Cell());

// Handle touch/click
function onInteract(x, y) {
  mouse.x = x; mouse.y = y; mouse.active = true;

  // More particles, varied sizes
  for (let i = 0; i < 35; i++) {
    touchParticles.push(new TouchParticle(x, y));
  }

  // Multiple ripple rings with delay
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      const ripple = document.createElement('div');
      ripple.className = 'touch-ripple';
      ripple.style.left = (x - 200) + 'px';
      ripple.style.top = (y - 200) + 'px';
      document.body.appendChild(ripple);
      setTimeout(() => ripple.remove(), 1500);
    }, i * 120);
  }

  // Central glow burst
  const glow = document.createElement('div');
  glow.className = 'touch-glow';
  glow.style.left = (x - 250) + 'px';
  glow.style.top = (y - 250) + 'px';
  document.body.appendChild(glow);
  setTimeout(() => glow.remove(), 1500);

  // Spawn new vessel from touch point
  const v = new Vessel();
  v.points = [{ x, y }];
  const segs = Math.floor(Math.random() * 5 + 4);
  for (let i = 0; i < segs; i++) {
    const last = v.points[v.points.length - 1];
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * 80 + 30;
    v.points.push({ x: last.x + Math.cos(angle) * dist, y: last.y + Math.sin(angle) * dist });
  }
  v.alpha = 0.25;
  v.width = 1.5;
  vessels.push(v);
  // Fade it out after a while
  setTimeout(() => {
    const idx = vessels.indexOf(v);
    if (idx > -1) vessels.splice(idx, 1);
  }, 4000);

  clearTimeout(window._mouseTimeout);
  window._mouseTimeout = setTimeout(() => { mouse.active = false; }, 2000);
}

document.addEventListener('click', e => onInteract(e.clientX, e.clientY));
document.addEventListener('touchstart', e => {
  for (const t of e.touches) onInteract(t.clientX, t.clientY);
}, { passive: true });
document.addEventListener('touchmove', e => {
  for (const t of e.touches) { mouse.x = t.clientX; mouse.y = t.clientY; }
}, { passive: true });

// Heartbeat subtle glow
function drawHeartbeat(t) {
  const beat = Math.pow(Math.sin(t * 0.004) * 0.5 + 0.5, 8);
  if (beat < 0.01) return;
  const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.5);
  gradient.addColorStop(0, `rgba(100, 10, 20, ${beat * 0.06})`);
  gradient.addColorStop(1, 'transparent');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
}

// Main loop
function animate(t) {
  time = t || 0;
  ctx.clearRect(0, 0, W, H);

  drawHeartbeat(time);
  vessels.forEach(v => v.draw(time));
  cells.forEach(c => { c.update(time); c.draw(); });

  touchParticles = touchParticles.filter(p => p.life > 0);
  touchParticles.forEach(p => { p.update(); p.draw(); });

  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
